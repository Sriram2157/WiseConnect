Liquid distortion image transitions (Three.js + shader)

On-scroll SVG morphing (flubber + GSAP ScrollTrigger)

3D floating cards (mouse parallax + GSAP)

Magnetic buttons (cursor magnetic effect)

Cursor-following text trails (canvas particle trail for letters)

Iâ€™ll give you the install command, file structure, and fully copy-pasteable code for each component plus notes on integration and performance. Follow the steps and youâ€™ll have the â€œEXTREMEâ€ UX.

âš™ï¸ Install (run once in your Replit project)
# basic libs used by EXTREME pack
npm install three gsap @react-three/fiber @react-three/drei flubber react-use
# optional helpers
npm install react-tsparticles

ðŸ—‚ File structure (add these files)
src/
  extreme/
    LiquidTransition.jsx
    shaders/
      displacement.frag
      displacement.vert
    MorphSection.jsx
    FloatingCard.jsx
    MagneticButton.jsx
    TextTrail.jsx
    extreme.css

1) Liquid distortion image transition (Three.js + shader)

What it does: displays an image plane that smoothly morphs between two images using a displacement map and a shader-based mix. Trigger on hover or via code (great for hero or card hover).

src/extreme/shaders/displacement.vert
precision mediump float;
attribute vec3 position;
attribute vec2 uv;
uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}

src/extreme/shaders/displacement.frag
precision mediump float;
varying vec2 vUv;
uniform sampler2D uTexture1;
uniform sampler2D uTexture2;
uniform sampler2D uDisp;
uniform float uMix;
uniform float uDispFactor;
void main() {
  vec2 disp = texture2D(uDisp, vUv).rg;
  vec2 dispVec = (disp * 2.0 - 1.0) * uDispFactor;
  vec2 uv1 = vUv + dispVec * (1.0 - uMix);
  vec2 uv2 = vUv - dispVec * uMix;
  vec4 tex1 = texture2D(uTexture1, uv1);
  vec4 tex2 = texture2D(uTexture2, uv2);
  vec4 final = mix(tex1, tex2, uMix);
  gl_FragColor = final;
}

src/extreme/LiquidTransition.jsx
import React, { useRef, useEffect, useState } from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls"; // dev only
import dispFrag from "./shaders/displacement.frag";
import dispVert from "./shaders/displacement.vert";
import "./extreme.css";

export default function LiquidTransition({ img1, img2, dispImg }) {
  const mount = useRef();
  const uniformsRef = useRef();

  useEffect(() => {
    const container = mount.current;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.z = 2;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // loader
    const loader = new THREE.TextureLoader();
    const texture1 = loader.load(img1, () => renderer.render(scene, camera));
    const texture2 = loader.load(img2, () => renderer.render(scene, camera));
    const disp = loader.load(dispImg);

    const geometry = new THREE.PlaneBufferGeometry(1.8, 1.0, 32, 32);
    const material = new THREE.ShaderMaterial({
      uniforms: {
        uTexture1: { value: texture1 },
        uTexture2: { value: texture2 },
        uDisp: { value: disp },
        uMix: { value: 0.0 },
        uDispFactor: { value: 0.15 }
      },
      vertexShader: dispVert,
      fragmentShader: dispFrag,
      transparent: true
    });

    uniformsRef.current = material.uniforms;

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Optional orbit controls while building (remove in production)
    // const controls = new OrbitControls(camera, renderer.domElement);

    let raf = null;
    const animate = () => {
      raf = requestAnimationFrame(animate);
      renderer.render(scene, camera);
    };
    animate();

    // resize handler
    const onResize = () => {
      renderer.setSize(container.clientWidth, container.clientHeight);
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
    };
    window.addEventListener("resize", onResize);

    return () => {
      cancelAnimationFrame(raf);
      window.removeEventListener("resize", onResize);
      container.removeChild(renderer.domElement);
      renderer.dispose();
    };
  }, [img1, img2, dispImg]);

  // external controls: expose a method to set mix (for hover)
  const setMix = (v) => {
    const u = uniformsRef.current;
    if (u) {
      u.uMix.value = v;
    }
  };

  return (
    <div
      className="liquid-wrap"
      ref={mount}
      onMouseEnter={() => setMix(1)}
      onMouseLeave={() => setMix(0)}
      role="img"
      aria-label="liquid transition"
    />
  );
}


Usage example (import into hero):

<LiquidTransition
  img1="/images/hero-a.jpg"
  img2="/images/hero-b.jpg"
  dispImg="/images/displacement.png"
/>


Note: displacement.png should be a grayscale texture with wavy noise.

2) On-scroll SVG morphing (flubber + GSAP ScrollTrigger)

What it does: morphs an SVG path into another as the user scrolls â€” perfect for section transitions and eye candy.

src/extreme/MorphSection.jsx
import React, { useRef, useEffect } from "react";
import gsap from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import * as flubber from "flubber";
import "./extreme.css";

gsap.registerPlugin(ScrollTrigger);

export default function MorphSection() {
  const pathRef = useRef(null);

  useEffect(() => {
    const startPath = "M10,80 Q80,10 150,80 T290,80"; // example simple path
    const endPath = "M10,50 Q80,120 150,50 T290,50";

    const interpolator = flubber.interpolate(startPath, endPath, { maxSegmentLength: 2 });

    ScrollTrigger.create({
      trigger: pathRef.current,
      start: "top bottom",
      end: "bottom top",
      onUpdate: (self) => {
        const t = self.progress;
        pathRef.current.setAttribute("d", interpolator(t));
      }
    });

    return () => ScrollTrigger.kill();
  }, []);

  return (
    <section className="morph-section reveal">
      <svg viewBox="0 0 300 100" preserveAspectRatio="xMidYMid meet" className="morph-svg">
        <path ref={pathRef} d="M10,80 Q80,10 150,80 T290,80" fill="none" stroke="#4f72ff" strokeWidth="4" strokeLinecap="round" />
      </svg>
    </section>
  );
}


Tip: Replace startPath/endPath with detailed paths created from Adobe Illustrator or an SVG editor. flubber helps interpolate complex shapes.

3) 3D Floating Cards (CSS 3D + GSAP parallax)

What it does: cards that tilt and float with depth when the mouse moves. Combine with shadows and soft motion to sell the 3D illusion.

src/extreme/FloatingCard.jsx
import React, { useRef, useEffect } from "react";
import gsap from "gsap";
import "./extreme.css";

export default function FloatingCard({ children }) {
  const ref = useRef();

  useEffect(() => {
    const el = ref.current;

    const onMove = (e) => {
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      const rotX = (y - 0.5) * 10; // tilt intensity
      const rotY = (x - 0.5) * -10;
      gsap.to(el, { rotationX: rotX, rotationY: rotY, scale: 1.03, duration: 0.6, ease: "power3.out" });
      gsap.to(el.querySelector(".card-shadow"), { x: (x - 0.5) * 20, y: (y - 0.5) * 20, duration: 0.6, ease: "power3.out" });
    };

    const onLeave = () => {
      gsap.to(el, { rotationX: 0, rotationY: 0, scale: 1, duration: 0.8, ease: "elastic.out(1,0.4)" });
      gsap.to(el.querySelector(".card-shadow"), { x: 0, y: 0, duration: 0.8, ease: "elastic.out(1,0.4)" });
    };

    el.addEventListener("mousemove", onMove);
    el.addEventListener("mouseleave", onLeave);
    return () => {
      el.removeEventListener("mousemove", onMove);
      el.removeEventListener("mouseleave", onLeave);
    };
  }, []);

  return (
    <div className="floating-card" ref={ref} style={{ transformStyle: "preserve-3d" }}>
      <div className="card-shadow" />
      <div className="card-inner">
        {children}
      </div>
    </div>
  );
}


CSS (part in extreme.css)

.floating-card {
  width: 320px;
  height: 220px;
  border-radius: 18px;
  background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(245,247,255,0.9));
  box-shadow: 0 12px 40px rgba(20,20,40,0.12);
  position: relative;
  perspective: 1000px;
  transform-origin: center;
  transition: transform 0.3s;
}

.card-inner {
  position: relative;
  z-index: 3;
  padding: 20px;
}

.card-shadow {
  position: absolute;
  z-index: 1;
  inset: 0;
  border-radius: 18px;
  filter: blur(20px);
  background: radial-gradient(circle at 50% 30%, rgba(79,114,255,0.12), transparent 40%);
  transform: translateZ(-30px);
}

4) Magnetic Buttons

What it does: when cursor approaches a button, the button gently moves toward the cursor giving a â€œmagneticâ€ feel.

src/extreme/MagneticButton.jsx
import React, { useRef, useEffect } from "react";
import gsap from "gsap";
import "./extreme.css";

export default function MagneticButton({ children, className = "", ...props }) {
  const btnRef = useRef();
  useEffect(() => {
    const el = btnRef.current;
    const strength = 0.35; // 0 - 1

    const move = (e) => {
      const rect = el.getBoundingClientRect();
      const relX = e.clientX - (rect.left + rect.width / 2);
      const relY = e.clientY - (rect.top + rect.height / 2);
      gsap.to(el, { x: relX * strength, y: relY * strength, duration: 0.35, ease: "power3.out" });
    };
    const leave = () => gsap.to(el, { x: 0, y: 0, duration: 0.6, ease: "elastic.out(1,0.6)" });

    el.addEventListener("mousemove", move);
    el.addEventListener("mouseleave", leave);
    return () => {
      el.removeEventListener("mousemove", move);
      el.removeEventListener("mouseleave", leave);
    };
  }, []);

  return (
    <button ref={btnRef} className={`magnetic-btn ${className}`} {...props}>
      {children}
    </button>
  );
}


CSS

.magnetic-btn {
  padding: 12px 28px;
  border-radius: 999px;
  background: linear-gradient(90deg,#5f81ff,#3b5acc);
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: 0 8px 28px rgba(59, 90, 204, 0.2);
  will-change: transform;
  transform: translate3d(0,0,0);
}

5) Cursor-following text trails (canvas)

What it does: when the user types or moves near text, letters/particles follow the cursor briefly, leaving trailing glyphs â€” cool effect for hero headings or interactive headings.

src/extreme/TextTrail.jsx
import React, { useRef, useEffect } from "react";
import "./extreme.css";

export default function TextTrail({ text = "WiseConnect" }) {
  const canvasRef = useRef();
  const trailRef = useRef([]);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");
    let w = canvas.width = window.innerWidth;
    let h = canvas.height = window.innerHeight;

    const resize = () => { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; };
    window.addEventListener("resize", resize);

    const letters = text.split("");
    const particles = [];

    const onMove = (e) => {
      const x = e.clientX;
      const y = e.clientY;
      // spawn a small set of letter particles
      for (let i = 0; i < Math.min(letters.length, 6); i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 2,
          vy: -Math.random() * 2 - 1,
          life: 0,
          ttl: 80 + Math.random() * 30,
          char: letters[(Math.floor(Math.random() * letters.length))]
        });
      }
    };

    window.addEventListener("mousemove", onMove);

    let raf;
    function render() {
      ctx.clearRect(0, 0, w, h);
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.08; // gravity
        p.life++;
        const alpha = 1 - p.life / p.ttl;
        ctx.globalAlpha = alpha;
        ctx.font = `${16 + (p.ttl - p.life) * 0.1}px system-ui, -apple-system`;
        ctx.fillStyle = `rgba(79,114,255, ${alpha})`;
        ctx.fillText(p.char, p.x, p.y);
        if (p.life > p.ttl) particles.splice(i, 1);
      }
      raf = requestAnimationFrame(render);
    }
    render();

    return () => {
      cancelAnimationFrame(raf);
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("resize", resize);
    };
  }, [text]);

  return <canvas ref={canvasRef} className="texttrail-canvas" />;
}


CSS

.texttrail-canvas {
  position: fixed;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 9998;
  width: 100%;
  height: 100%;
}

Integration example (use everything on a page)
import React from "react";
import LiquidTransition from "./extreme/LiquidTransition";
import MorphSection from "./extreme/MorphSection";
import FloatingCard from "./extreme/FloatingCard";
import MagneticButton from "./extreme/MagneticButton";
import TextTrail from "./extreme/TextTrail";

export default function EpicPage() {
  return (
    <main>
      <TextTrail text="WiseConnect" />
      <header style={{ position: "relative", height: "80vh" }}>
        <LiquidTransition
          img1="/images/heroA.jpg"
          img2="/images/heroB.jpg"
          dispImg="/images/displacement.png"
        />
        <div style={{ position: "absolute", zIndex: 10, left: "50%", top: "50%", transform: "translate(-50%,-50%)", textAlign: "center" }}>
          <h1 style={{ color: "#fff", fontSize: "48px" }}>WiseConnect</h1>
          <MagneticButton>Get Started</MagneticButton>
        </div>
      </header>

      <section style={{ padding: 80 }}>
        <h2>Features</h2>
        <div style={{ display: "flex", gap: 32 }}>
          <FloatingCard><h3>Lesson 1</h3><p>Intro to email</p></FloatingCard>
          <FloatingCard><h3>Lesson 2</h3><p>Video calls</p></FloatingCard>
        </div>
      </section>

      <MorphSection />
    </main>
  );
}